// @ts-nocheck
// ── Manifold evasion: Font Enumeration ───────────────────────────────────────
//
// Blocks three font-fingerprinting attack vectors:
//
//   1. CSS font-face enumeration via document.fonts (FontFaceSet)
//        • document.fonts.check()   → returns true only for subset fonts
//        • document.fonts.load()    → resolves for subset fonts, rejects others
//        • document.fonts[Symbol.iterator] / .forEach / .entries / .values / .keys
//          → yields only subset FontFace objects
//        • document.fonts.size      → reports subset count
//
//   2. Canvas text-width probing
//        CanvasRenderingContext2D.measureText() adds per-font-per-seed noise
//        to the returned TextMetrics.width so cross-profile width comparisons
//        fail while single-session rendering is stable.
//
//   3. CSS @font-face detection via element.style.fontFamily assignment
//        We intercept CSSStyleDeclaration.setProperty / fontFamily setter to
//        detect when page code tries to probe font availability by measuring
//        layout, and redirect unknown fonts to a seeded alias from the subset.
//
// Paranoid mode: if cfg.fonts.subset.length < 50 we enforce strict filtering.
// Otherwise we allow any font that Chrome would normally expose.
//
// Reference subset: the font list stored in the profile's font_subset array,
// generated by FingerprintOrchestrator.build_font_subset() in Rust.
//
// All overrides are idempotent; a __m_fonts_patched__ guard prevents
// double-application.

import type { EvasionConfig } from "./types.js";

export function fontsEvasion(cfg: EvasionConfig): string {
  const { fonts, seed } = cfg;

  const subset     = fonts.subset;
  const paranoid   = subset.length < 50;

  if (!paranoid && subset.length === 0) {
    return "/* fonts evasion: no subset defined, skipping */";
  }

  const subsetJson = JSON.stringify(subset);

  return /* js */`(function () {
  'use strict';

  if (window.__m_fonts_patched__) return;

  // ── Profile font subset (from Rust FingerprintOrchestrator) ──────────────
  const _SUBSET     = new Set(${subsetJson});
  const _SUBSET_ARR = ${subsetJson};
  const _PARANOID   = ${paranoid};
  const _SEED32     = ${seed} >>> 0;

  // ── Font name normalisation ───────────────────────────────────────────────
  // Strip quotes and normalise casing for comparison.
  function _normFont(name) {
    return name.replace(/['"]/g, '').trim().toLowerCase();
  }

  function _inSubset(name) {
    const n = _normFont(name);
    for (const f of _SUBSET) {
      if (f.toLowerCase() === n) return true;
    }
    return false;
  }

  // ── 1. document.fonts (FontFaceSet) ──────────────────────────────────────

  if (typeof FontFaceSet !== 'undefined' && document.fonts) {
    const _realFonts = document.fonts;

    // ── 1a. check() ──────────────────────────────────────────────────────
    const _origCheck = _realFonts.check.bind(_realFonts);
    Object.defineProperty(FontFaceSet.prototype, 'check', {
      configurable: true,
      enumerable:   false,
      writable:     true,
      value: function check(font, text) {
        // Parse font shorthand to extract family names
        // e.g. '12px "Arial"' → 'Arial'
        const families = _parseFontFamilies(font);
        if (families.length === 0) return _origCheck(font, text);

        // In paranoid mode: only return true for subset fonts
        if (_PARANOID) {
          return families.every(f => _inSubset(f));
        }
        return _origCheck(font, text);
      },
    });

    // ── 1b. load() ───────────────────────────────────────────────────────
    const _origLoad = _realFonts.load.bind(_realFonts);
    Object.defineProperty(FontFaceSet.prototype, 'load', {
      configurable: true,
      enumerable:   false,
      writable:     true,
      value: function load(font, text) {
        const families = _parseFontFamilies(font);
        if (_PARANOID && families.length > 0) {
          const allowed = families.filter(f => _inSubset(f));
          if (allowed.length === 0) {
            // Return a rejected promise for out-of-subset fonts
            return Promise.reject(new DOMException(
              'Font not available in profile subset',
              'NotFoundError'
            ));
          }
        }
        return _origLoad(font, text);
      },
    });

    // ── 1c. Iteration (size, forEach, Symbol.iterator, entries, keys, values)
    //    We intercept the size getter and iteration methods to expose only
    //    subset FontFace objects. This prevents enumeration via
    //    [...document.fonts] or for..of loops.

    const _origSizeDesc = Object.getOwnPropertyDescriptor(FontFaceSet.prototype, 'size');

    if (_PARANOID) {
      // Override size to report subset count
      try {
        Object.defineProperty(FontFaceSet.prototype, 'size', {
          get: function size() {
            // Count real loaded faces that match the subset
            let count = 0;
            for (const face of _iterRealFonts(_realFonts)) {
              if (_inSubset(face.family)) count++;
            }
            // Always report at least the subset length (faces may not be loaded yet)
            return Math.max(_SUBSET_ARR.length, count);
          },
          configurable: true,
          enumerable:   true,
        });
      } catch (_) { /* best-effort */ }

      // Override forEach
      const _origForEach = FontFaceSet.prototype.forEach;
      if (_origForEach) {
        Object.defineProperty(FontFaceSet.prototype, 'forEach', {
          configurable: true,
          enumerable:   false,
          writable:     true,
          value: function forEach(cb, thisArg) {
            for (const face of _iterRealFonts(this)) {
              if (_inSubset(face.family)) {
                cb.call(thisArg, face, face, this);
              }
            }
          },
        });
      }

      // Override Symbol.iterator
      Object.defineProperty(FontFaceSet.prototype, Symbol.iterator, {
        configurable: true,
        enumerable:   false,
        writable:     true,
        value: function* () {
          for (const face of _iterRealFonts(this)) {
            if (_inSubset(face.family)) yield face;
          }
        },
      });
    }
  }

  // Helper: safely iterate real FontFaceSet without triggering our override
  function* _iterRealFonts(ffs) {
    try {
      const origIter = FontFaceSet.prototype[Symbol.iterator];
      if (origIter) {
        // Use the original iterator if it hasn't been replaced yet
        // (called during initialisation before the override kicks in)
        for (const f of ffs) yield f;
      }
    } catch (_) { /* no-op if iterator is already patched */ }
  }

  // ── Font shorthand parser ─────────────────────────────────────────────────
  // Extracts family names from a CSS font shorthand like '16px Arial, sans-serif'
  // or '"Helvetica Neue", Arial'.
  function _parseFontFamilies(font) {
    if (!font || typeof font !== 'string') return [];
    // Strip size/style/weight prefix (everything before the last /)
    // Then split on commas
    const familyPart = font.replace(
      /^(?:(?:normal|bold|bolder|lighter|\d{3}|italic|oblique|small-caps)\s+)*(?:[\d.]+(?:px|pt|em|rem|%|vh|vw)\s*(?:\/\s*[\d.]+(?:px|pt|em|rem|%|vh|vw|normal)?\s*)?)?/i,
      ''
    ).trim();

    return familyPart
      .split(',')
      .map(f => f.replace(/['"]/g, '').trim())
      .filter(f => f.length > 0 && !['serif','sans-serif','monospace','cursive','fantasy','system-ui','ui-serif','ui-sans-serif','ui-monospace','ui-rounded','inherit','initial','revert','unset'].includes(f.toLowerCase()));
  }

  // ── 2. CanvasRenderingContext2D.measureText noise ─────────────────────────
  //
  // Fingerprinters draw text in specific fonts and measure the width.
  // We add a seed-keyed, font-keyed noise delta to the returned width.
  //
  // Delta formula: per (seed, fontFamily, fontSize, text) → stable ±0.5px jitter.
  // This is small enough to not break most legitimate text rendering but enough
  // to prevent cross-session comparison.

  if (typeof CanvasRenderingContext2D !== 'undefined') {
    const _origMT = CanvasRenderingContext2D.prototype.measureText;

    Object.defineProperty(CanvasRenderingContext2D.prototype, 'measureText', {
      configurable: true,
      enumerable:   false,
      writable:     true,
      value: function measureText(text) {
        const metrics = _origMT.call(this, text);

        // Compute noise: hash of (seed, font string, text content)
        const fontStr = this.font ?? '';
        let h = _SEED32;
        for (let i = 0; i < fontStr.length; i++) {
          h = Math.imul(h ^ fontStr.charCodeAt(i), 0x9e3779b9) >>> 0;
        }
        for (let i = 0; i < Math.min(text.length, 32); i++) {
          h = Math.imul(h ^ text.charCodeAt(i), 0x85ebca6b) >>> 0;
        }
        h = Math.imul(h ^ (h >>> 16), 0x45d9f3b) >>> 0;
        h = (h ^ (h >>> 13)) >>> 0;
        h = Math.imul(h, 0xc2b2ae35) >>> 0;
        h = (h ^ (h >>> 16)) >>> 0;

        // Delta: ±0.5px maximum
        const delta = ((h / 0x100000000) - 0.5) * 1.0;  // –0.5 to +0.5 px

        // Return a proxy TextMetrics with noised width
        // We use Object.create to preserve instanceof checks
        const fakeMetrics = Object.create(Object.getPrototypeOf(metrics));
        const realWidth = metrics.width + delta;

        Object.defineProperties(fakeMetrics, {
          width:                    { get: () => realWidth,              enumerable: true, configurable: true },
          actualBoundingBoxLeft:    { get: () => metrics.actualBoundingBoxLeft,    enumerable: true, configurable: true },
          actualBoundingBoxRight:   { get: () => metrics.actualBoundingBoxRight + delta, enumerable: true, configurable: true },
          actualBoundingBoxAscent:  { get: () => metrics.actualBoundingBoxAscent,  enumerable: true, configurable: true },
          actualBoundingBoxDescent: { get: () => metrics.actualBoundingBoxDescent, enumerable: true, configurable: true },
          fontBoundingBoxAscent:    { get: () => metrics.fontBoundingBoxAscent,    enumerable: true, configurable: true },
          fontBoundingBoxDescent:   { get: () => metrics.fontBoundingBoxDescent,   enumerable: true, configurable: true },
        });

        return fakeMetrics;
      },
    });
  }

  // ── 3. CSS fontFamily setter interception ─────────────────────────────────
  //
  // Some fingerprinters probe font availability by:
  //   elem.style.fontFamily = 'TestFont, monospace';
  //   document.body.appendChild(elem);
  //   // measure offsetWidth — differs if TestFont loads
  //
  // In paranoid mode we redirect unknown fonts to a random subset member so
  // the layout measurement doesn't reveal the real installed font set.

  if (_PARANOID && typeof CSSStyleDeclaration !== 'undefined') {
    const _proto    = CSSStyleDeclaration.prototype;
    const _origSP   = _proto.setProperty;
    const _origFFDesc = Object.getOwnPropertyDescriptor(_proto, 'fontFamily');

    // Pick a seeded fallback from the subset for unknown fonts
    function _subsetFallback() {
      const idx = (_SEED32 % _SUBSET_ARR.length + _SUBSET_ARR.length) % _SUBSET_ARR.length;
      return _SUBSET_ARR[idx] ?? 'sans-serif';
    }

    function _filterFontFamily(value) {
      if (!value || typeof value !== 'string') return value;
      const parts = value.split(',').map(f => f.trim());
      const filtered = parts.map(f => {
        const clean = f.replace(/['"]/g, '').trim();
        // Keep CSS generic families and subset fonts
        const generics = ['serif','sans-serif','monospace','cursive','fantasy','system-ui',
                          'ui-serif','ui-sans-serif','ui-monospace','ui-rounded'];
        if (generics.some(g => g === clean.toLowerCase())) return f;
        if (_inSubset(clean)) return f;
        // Replace unknown font with seeded subset member
        return '"' + _subsetFallback() + '"';
      });
      return filtered.join(', ');
    }

    // Override setProperty for 'font-family'
    if (_origSP) {
      Object.defineProperty(_proto, 'setProperty', {
        configurable: true,
        enumerable:   false,
        writable:     true,
        value: function setProperty(property, value, priority) {
          if (property === 'font-family' || property === 'fontFamily') {
            value = _filterFontFamily(value);
          }
          return _origSP.call(this, property, value, priority);
        },
      });
    }

    // Override fontFamily getter/setter
    if (_origFFDesc && _origFFDesc.set) {
      try {
        Object.defineProperty(_proto, 'fontFamily', {
          get: _origFFDesc.get,
          set: function fontFamily(value) {
            _origFFDesc.set.call(this, _filterFontFamily(value));
          },
          configurable: true,
          enumerable:   true,
        });
      } catch (_) { /* best-effort */ }
    }
  }

  // ── 4. navigator.fonts (Local Font Access API) ────────────────────────────
  //
  // Chrome 103+ exposes navigator.fonts.query() which returns all installed
  // system fonts. Block this entirely — it's the highest-entropy font vector.

  if (navigator.fonts) {
    try {
      Object.defineProperty(navigator, 'fonts', {
        get: () => ({
          query: () => Promise.reject(new DOMException('NotAllowedError', 'Permission denied')),
        }),
        configurable: true,
        enumerable:   true,
      });
    } catch (_) {
      // If navigator.fonts is non-configurable, override query only
      try {
        Object.defineProperty(navigator.fonts, 'query', {
          value: () => Promise.reject(new DOMException('NotAllowedError', 'Permission denied')),
          configurable: true,
          enumerable:   true,
          writable:     true,
        });
      } catch (__) { /* best-effort */ }
    }
  }

  // ── Guard ─────────────────────────────────────────────────────────────────
  Object.defineProperty(window, '__m_fonts_patched__', {
    value: _PARANOID ? 'paranoid' : 'normal',
    writable: false,
    configurable: false,
  });

})();`;
}

export type { EvasionConfig };
